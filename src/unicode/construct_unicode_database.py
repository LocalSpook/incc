#!/usr/bin/env python3

import argparse
import xml.etree.ElementTree as ET
from more_itertools import consecutive_groups
from typing import Iterable, Callable
import sys
import itertools
import os
from dataclasses import dataclass

def parse_command_line_arguments():
	parser = argparse.ArgumentParser(
		description="Construct a C++ Unicode database from the official XML database."
	)
	parser.add_argument(
		"-d", "--xml-database",
		required=True,
		type=argparse.FileType("r", encoding="utf-8"),
		help="Path to the Unicode XML database."
	)
	parser.add_argument(
		"-o", "--output",
		type=argparse.FileType("w+", encoding="utf-8"),
		default=sys.stdout,
		help="C++ header file to write the database to."
	)
	return parser.parse_args()

def code_points_satisfying(property_name: str, code_points: Iterable[ET.Element], condition: Callable) -> str:
	matching_code_points = []

	for c in code_points:
		if condition(c):
			if c.get("cp") is not None:
				matching_code_points.append(int(c.get("cp"), 16))
			elif c.get("first-cp") is not None and c.get("last-cp") is not None:
				matching_code_points.extend(
					range(int(c.get("first-cp"), 16), int(c.get("last-cp"), 16) + 1)
				)

	ranges = [list(g) for g in consecutive_groups(matching_code_points)]

	ret = f"template <>\n"
	ret += f"[[nodiscard]] constexpr bool has_property<{property_name}>(const code_point c) noexcept {{\n"
	ret += f"\tASSERT_OR_ASSUME_CODE_POINT_IS_VALID(c);\n\n"

	ret += f"\tstatic constexpr std::array<code_point_range, {len(ranges)}> code_point_ranges {{{{\n"
	for r in ranges:
		ret += f"\t\t{{0x{r[0]:06X}, 0x{r[-1]:06X}}},\n"
	ret += f"\t}}}};\n\n"

	ret += f"\treturn std::binary_search(std::cbegin(code_point_ranges), std::cend(code_point_ranges), c);\n"
	ret += f"}}"

	return ret

def binary_properties(code_points: Iterable[ET.Element], properties: dict[str, Callable]) -> str:
	ret = f"enum class binary_property : std::uint32_t {{\n"
	for name in properties:
		ret += f"\t{name},\n"
	ret += f"}};\n\n"

	ret += """\
template <binary_property property>
[[nodiscard]] constexpr bool has_property(code_point) noexcept = delete;
"""

	for name, condition in properties.items():
		ret += f"\n{code_points_satisfying(f"binary_property::{name}", code_points, condition)}\n"

	return ret

@dataclass
class CodePointAge:
	major: str
	minor: str
	code_point: int

def age(code_points: Iterable[ET.Element]) -> str:
	ret = f"""\
[[nodiscard]] constexpr std::optional<std::pair<std::uint8_t, std::uint8_t>> age(const code_point c) noexcept {{
	ASSERT_OR_ASSUME_CODE_POINT_IS_VALID(c);

	struct compact_code_point_range_and_version final {{
		bool assigned : 1;
		std::uint8_t version_major : 5;
		std::uint8_t version_minor : 5;
		code_point upper_bound : 21;
	}};

	static_assert(sizeof(compact_code_point_range_and_version) <= 4);
"""

	ages = []
	for c in code_points:
		if age.contains("."):
			major, minor = c.get("age").split(".")
		else:
			major, minor = None, None
		if c.get("cp") is not None:
			ages.append(CodePointAge(major, minor, int(c.get("cp"), 16)))
		elif c.get("first-cp") is not None and c.get("last-cp") is not None:
			for n in range(int(c.get("first-cp"), 16), int(c.get("last-cp"), 16) + 1):
				ages.append(CodePointAge(major, minor, n))
	ranges = [list(g) for g in itertools.groupby(ages)]

	ret += f"\tstatic constexpr std::array<compact_code_point_range_and_version, {len(ranges)}> code_point_ranges {{\n"
	for r in ranges:
		ret += f"\t\t{{}},\n"
	ret += f"}}\n\n"

	ret += f"""\
	const auto age {{std::lower_bound(std::cbegin(code_point_ranges), std::cend(code_point_ranges), c, [] (const compact_code_point_range_and_version& r, const code_point c) noexcept {{ return c > r.upper_bound; }})}};
	return age.assigned ? {{age.version_major, age.version_minor}} : std::nullopt;
}}"""

	return ret

def main() -> None:
	args = parse_command_line_arguments()
	xml_root = ET.parse(args.xml_database).getroot()
	code_points = xml_root.find("{http://www.unicode.org/ns/2003/ucd/1.0}repertoire").findall("{http://www.unicode.org/ns/2003/ucd/1.0}char")

	args.output.write(f"""\
// SPDX-License-Identifier: Unlicense

// This file was automatically generated by {os.path.basename(__file__)}. Do not edit it directly!

#pragma once

#include <algorithm>
#include <array>
#include <cstdint>
#include <optional>

#ifndef NDEBUG

#include <cassert>

#define ASSERT_OR_ASSUME_CODE_POINT_IS_VALID(c) \\
	if constexpr {{                              \\
		static_assert(is_valid_code_point(c));  \\
	}} else {{                                    \\
		assert(is_valid_code_point(c));         \\
	}}

#else

#define ASSERT_OR_ASSUME_CODE_POINT_IS_VALID(c) \\
	if constexpr {{                              \\
		static_assert(is_valid_code_point(c));  \\
	}} else {{                                    \\
		[[assume(is_valid_code_point(c))]];     \\
	}}

#endif

namespace unicode {{

using code_point = std::uint32_t;

inline constexpr code_point maximum_code_point_value {{0x10FFFF}};

[[nodiscard]] constexpr bool is_valid_code_point(const code_point c) noexcept {{
	return c <= maximum_code_point_value;
}}

/// A closed range of code points.
struct code_point_range final {{
	code_point lower_bound;
	code_point upper_bound;
}};

constexpr bool operator <(const code_point c, const code_point_range& r) noexcept {{
	return c < r.lower_bound;
}}

constexpr bool operator <(const code_point_range& r, const code_point c) noexcept {{
	return c > r.upper_bound;
}}

{binary_properties(code_points, {
	"xid_start": lambda c: c.get("XIDS") == "Y" or c.get("ID_Compat_Math_Start") == "Y" or c.get("na") in ["LOW LINE"],
	"xid_continue": lambda c: c.get("XIDC") == "Y" or c.get("ID_Compat_Math_Continue") == "Y",
	# https://www.unicode.org/reports/tr31/#Whitespace_and_Syntax
	"end_of_line": lambda c: c.get("cp") in [
		"000A",
		"000B",
		"000C",
		"000D",
		"0085",
		"2028",
		"2029",
	],
	"ignorable_format_control": lambda c: c.get("Pat_WS") == "Y" and c.get("DI") == "Y",
	"horizontal_space": lambda c: c.get("Pat_WS") == "Y" and c.get("DI") == "N" and c.get("cp") not in [
		"000A",
		"000B",
		"000C",
		"000D",
		"0085",
		"2028",
		"2029",
	],
	"deprecated": lambda c: c.get("Dep") == "Y",
	"default_ignorable": lambda c: c.get("DI") == "Y",
})}

{age(code_points)}

}} // namespace unicode
""")

if __name__ == "__main__":
	main()
